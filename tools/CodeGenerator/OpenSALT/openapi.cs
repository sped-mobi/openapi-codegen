//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.2)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."

namespace Microsoft.OpenApi.CodeGeneration.OpenSALT
{
    using System = global::System;
    
    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.2))")]
    public partial interface IOpenSALTClient
    {
        /// <summary>The REST read request message for the getCFAssociationGrouping() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework AssociationGrouping that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFAssociationGrouping from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CFAssociationGrouping> GetCFAssociationGroupingAsync(string sourcedId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>The REST read request message for the getCFAssociationGrouping() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework AssociationGrouping that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFAssociationGrouping from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CFAssociationGrouping> GetCFAssociationGroupingAsync(string sourcedId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>The REST read request message for the getCFAssociation() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the CFAssociation to be supplied.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFAssociation from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CFAssociation> GetCFAssociationAsync(string sourcedId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>The REST read request message for the getCFAssociation() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the CFAssociation to be supplied.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFAssociation from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CFAssociation> GetCFAssociationAsync(string sourcedId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>The REST read request message for the getCFConcept() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework Concept that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFConcept and child CFSConcepts from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CFConceptSet> GetCFConceptAsync(string sourcedId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>The REST read request message for the getCFConcept() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework Concept that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFConcept and child CFSConcepts from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CFConceptSet> GetCFConceptAsync(string sourcedId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>The REST read request message for the getAllCFDocuments() API call.</summary>
        /// <param name="limit">This is used as part of the data pagination mechanism to control the download rate of data. The 'limit' defines the download segmentation value i.e. the maximum number of records to be contained in the response. The form of implementation is described in the corresponding binding document(s).</param>
        /// <param name="offset">This is used as part of the data pagination mechanism to control the download rate of data. The 'offset' is the number of the first record to be supplied in the segmented response message. The form of implementation is described in the corresponding binding document(s).</param>
        /// <param name="sort">This is used as part of the sorting mechanism to be use by the service provider. The 'sort' identifies the sort criteria to be used for the records in the response message. Use with the orderBy parameter. The form of implementation is described in the corresponding binding document(s).</param>
        /// <param name="orderBy">This is used as part of the sorting mechanism to be use by the service provider. This defines the form of ordering for response to the sorted request i.e. ascending (asc) or descending (desc). The form of implementation is described in the corresponding binding document(s).</param>
        /// <param name="filter">This is used for the data filtering mechanism to be applied by the service provider. It defines the filtering rules to be applied when identifying the records to be supplied in the response message. The form of implementation is described in the corresponding binding document(s).</param>
        /// <param name="fields">This is used as part of the field selection mechanism to be applied by the service provider. This identifies the range of fields that should be supplied in the response message. The form of implementation is described in the corresponding binding document(s).</param>
        /// <returns>This is the response when the request has been completed successfully. It is the set of CFDocuments from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CFDocumentSet> GetAllCFDocumentsAsync(int? limit, int? offset, string sort, OrderBy? orderBy, string filter, System.Collections.Generic.IEnumerable<string> fields);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>The REST read request message for the getAllCFDocuments() API call.</summary>
        /// <param name="limit">This is used as part of the data pagination mechanism to control the download rate of data. The 'limit' defines the download segmentation value i.e. the maximum number of records to be contained in the response. The form of implementation is described in the corresponding binding document(s).</param>
        /// <param name="offset">This is used as part of the data pagination mechanism to control the download rate of data. The 'offset' is the number of the first record to be supplied in the segmented response message. The form of implementation is described in the corresponding binding document(s).</param>
        /// <param name="sort">This is used as part of the sorting mechanism to be use by the service provider. The 'sort' identifies the sort criteria to be used for the records in the response message. Use with the orderBy parameter. The form of implementation is described in the corresponding binding document(s).</param>
        /// <param name="orderBy">This is used as part of the sorting mechanism to be use by the service provider. This defines the form of ordering for response to the sorted request i.e. ascending (asc) or descending (desc). The form of implementation is described in the corresponding binding document(s).</param>
        /// <param name="filter">This is used for the data filtering mechanism to be applied by the service provider. It defines the filtering rules to be applied when identifying the records to be supplied in the response message. The form of implementation is described in the corresponding binding document(s).</param>
        /// <param name="fields">This is used as part of the field selection mechanism to be applied by the service provider. This identifies the range of fields that should be supplied in the response message. The form of implementation is described in the corresponding binding document(s).</param>
        /// <returns>This is the response when the request has been completed successfully. It is the set of CFDocuments from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CFDocumentSet> GetAllCFDocumentsAsync(int? limit, int? offset, string sort, OrderBy? orderBy, string filter, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>The REST read request message for the getCFDocument() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework Document that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFDocument from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CFDocument> GetCFDocumentAsync(string sourcedId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>The REST read request message for the getCFDocument() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework Document that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFDocument from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CFDocument> GetCFDocumentAsync(string sourcedId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>The REST read request message for the getCFItemAssociations() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the CFItem for which ALL associations are to be supplied.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFItem and set of CFAssociations from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CFAssociationSet> GetCFItemAssociationsAsync(string sourcedId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>The REST read request message for the getCFItemAssociations() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the CFItem for which ALL associations are to be supplied.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFItem and set of CFAssociations from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CFAssociationSet> GetCFItemAssociationsAsync(string sourcedId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>The REST read request message for the getCFItemType() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework ItemType that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFItemType and child CFItemTypes from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CFItemTypeSet> GetCFItemTypeAsync(string sourcedId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>The REST read request message for the getCFItemType() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework ItemType that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFItemType and child CFItemTypes from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CFItemTypeSet> GetCFItemTypeAsync(string sourcedId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>The REST read request message for the getCFItem() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework Item that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFItem from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CFItem> GetCFItemAsync(string sourcedId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>The REST read request message for the getCFItem() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework Item that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFItem from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CFItem> GetCFItemAsync(string sourcedId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>The REST read request message for the getCFLicense() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework License that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFLicense from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CFLicense> GetCFLicenseAsync(string sourcedId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>The REST read request message for the getCFLicense() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework License that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFLicense from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CFLicense> GetCFLicenseAsync(string sourcedId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>The REST read request message for the getCFPackage() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework Document that is to be read from the service provider and supplied with all of its component artefacts.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFPackage from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CFPackage> GetCFPackageAsync(string sourcedId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>The REST read request message for the getCFPackage() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework Document that is to be read from the service provider and supplied with all of its component artefacts.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFPackage from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CFPackage> GetCFPackageAsync(string sourcedId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>The REST read request message for the getCFRubric() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework Rubric that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFRubric from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CFRubric> GetCFRubricAsync(string sourcedId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>The REST read request message for the getCFRubric() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework Rubric that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFRubric from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CFRubric> GetCFRubricAsync(string sourcedId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>The REST read request message for the getCFSubject() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework Subject that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFSubject and child CFSubjects from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CFSubjectSet> GetCFSubjectAsync(string sourcedId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>The REST read request message for the getCFSubject() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework Subject that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFSubject and child CFSubjects from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CFSubjectSet> GetCFSubjectAsync(string sourcedId, System.Threading.CancellationToken cancellationToken);
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.2))")]
    public partial class OpenSALTClient : IOpenSALTClient
    {
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;
    
        public OpenSALTClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient; 
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }
    
        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }
    
        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }
    
        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);
    
        /// <summary>The REST read request message for the getCFAssociationGrouping() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework AssociationGrouping that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFAssociationGrouping from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CFAssociationGrouping> GetCFAssociationGroupingAsync(string sourcedId)
        {
            return GetCFAssociationGroupingAsync(sourcedId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>The REST read request message for the getCFAssociationGrouping() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework AssociationGrouping that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFAssociationGrouping from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CFAssociationGrouping> GetCFAssociationGroupingAsync(string sourcedId, System.Threading.CancellationToken cancellationToken)
        {
            if (sourcedId == null)
                throw new System.ArgumentNullException("sourcedId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("CFAssociationGroupings/{sourcedId}");
            urlBuilder_.Replace("{sourcedId}", System.Uri.EscapeDataString(ConvertToString(sourcedId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CFAssociationGrouping>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("An invalid selection field was supplied and data filtering on the selection criteria was not possible i.e. \'invalid_selection_field\'. This is accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("The request was not correctly authorised i.e. \'unauthorisedrequest\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This is used to indicate that the server can be reached and process the request but refuses to take any further action i.e. \'forbidden\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("Either the supplied identifier is unknown in the Service Provider and so the object could not be changed or an invalid UUID has been supplied. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'. The statement \'Unknown Object\' of \'Invalid UUID\' should also be presented.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("The server is receiving too many requests i.e. \'server_busy\'. Retry at a later time. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This code should be used only if there is catastrophic error and there is not a more appropriate code i.e. \'internal_server_error\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This is the response data payload to be supplied when the HTTP code is NOT explicitly defined. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\' and the appropriate \'codeMinor\' value. The associated HTTP code will also be supplied.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>The REST read request message for the getCFAssociation() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the CFAssociation to be supplied.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFAssociation from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CFAssociation> GetCFAssociationAsync(string sourcedId)
        {
            return GetCFAssociationAsync(sourcedId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>The REST read request message for the getCFAssociation() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the CFAssociation to be supplied.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFAssociation from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CFAssociation> GetCFAssociationAsync(string sourcedId, System.Threading.CancellationToken cancellationToken)
        {
            if (sourcedId == null)
                throw new System.ArgumentNullException("sourcedId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("CFAssociations/{sourcedId}");
            urlBuilder_.Replace("{sourcedId}", System.Uri.EscapeDataString(ConvertToString(sourcedId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CFAssociation>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("An invalid selection field was supplied and data filtering on the selection criteria was not possible i.e. \'invalid_selection_field\'. This is accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("The request was not correctly authorised i.e. \'unauthorisedrequest\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This is used to indicate that the server can be reached and process the request but refuses to take any further action i.e. \'forbidden\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("Either the supplied identifier is unknown in the Service Provider and so the object could not be changed or an invalid UUID has been supplied. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'. The statement \'Unknown Object\' of \'Invalid UUID\' should also be presented.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("The server is receiving too many requests i.e. \'server_busy\'. Retry at a later time. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This code should be used only if there is catastrophic error and there is not a more appropriate code i.e. \'internal_server_error\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This is the response data payload to be supplied when the HTTP code is NOT explicitly defined. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\' and the appropriate \'codeMinor\' value. The associated HTTP code will also be supplied.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>The REST read request message for the getCFConcept() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework Concept that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFConcept and child CFSConcepts from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CFConceptSet> GetCFConceptAsync(string sourcedId)
        {
            return GetCFConceptAsync(sourcedId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>The REST read request message for the getCFConcept() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework Concept that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFConcept and child CFSConcepts from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CFConceptSet> GetCFConceptAsync(string sourcedId, System.Threading.CancellationToken cancellationToken)
        {
            if (sourcedId == null)
                throw new System.ArgumentNullException("sourcedId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("CFConcepts/{sourcedId}");
            urlBuilder_.Replace("{sourcedId}", System.Uri.EscapeDataString(ConvertToString(sourcedId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CFConceptSet>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("An invalid selection field was supplied and data filtering on the selection criteria was not possible i.e. \'invalid_selection_field\'. This is accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("The request was not correctly authorised i.e. \'unauthorisedrequest\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This is used to indicate that the server can be reached and process the request but refuses to take any further action i.e. \'forbidden\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("Either the supplied identifier is unknown in the Service Provider and so the object could not be changed or an invalid UUID has been supplied. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'. The statement \'Unknown Object\' of \'Invalid UUID\' should also be presented.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("The server is receiving too many requests i.e. \'server_busy\'. Retry at a later time. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This code should be used only if there is catastrophic error and there is not a more appropriate code i.e. \'internal_server_error\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This is the response data payload to be supplied when the HTTP code is NOT explicitly defined. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\' and the appropriate \'codeMinor\' value. The associated HTTP code will also be supplied.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>The REST read request message for the getAllCFDocuments() API call.</summary>
        /// <param name="limit">This is used as part of the data pagination mechanism to control the download rate of data. The 'limit' defines the download segmentation value i.e. the maximum number of records to be contained in the response. The form of implementation is described in the corresponding binding document(s).</param>
        /// <param name="offset">This is used as part of the data pagination mechanism to control the download rate of data. The 'offset' is the number of the first record to be supplied in the segmented response message. The form of implementation is described in the corresponding binding document(s).</param>
        /// <param name="sort">This is used as part of the sorting mechanism to be use by the service provider. The 'sort' identifies the sort criteria to be used for the records in the response message. Use with the orderBy parameter. The form of implementation is described in the corresponding binding document(s).</param>
        /// <param name="orderBy">This is used as part of the sorting mechanism to be use by the service provider. This defines the form of ordering for response to the sorted request i.e. ascending (asc) or descending (desc). The form of implementation is described in the corresponding binding document(s).</param>
        /// <param name="filter">This is used for the data filtering mechanism to be applied by the service provider. It defines the filtering rules to be applied when identifying the records to be supplied in the response message. The form of implementation is described in the corresponding binding document(s).</param>
        /// <param name="fields">This is used as part of the field selection mechanism to be applied by the service provider. This identifies the range of fields that should be supplied in the response message. The form of implementation is described in the corresponding binding document(s).</param>
        /// <returns>This is the response when the request has been completed successfully. It is the set of CFDocuments from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CFDocumentSet> GetAllCFDocumentsAsync(int? limit, int? offset, string sort, OrderBy? orderBy, string filter, System.Collections.Generic.IEnumerable<string> fields)
        {
            return GetAllCFDocumentsAsync(limit, offset, sort, orderBy, filter, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>The REST read request message for the getAllCFDocuments() API call.</summary>
        /// <param name="limit">This is used as part of the data pagination mechanism to control the download rate of data. The 'limit' defines the download segmentation value i.e. the maximum number of records to be contained in the response. The form of implementation is described in the corresponding binding document(s).</param>
        /// <param name="offset">This is used as part of the data pagination mechanism to control the download rate of data. The 'offset' is the number of the first record to be supplied in the segmented response message. The form of implementation is described in the corresponding binding document(s).</param>
        /// <param name="sort">This is used as part of the sorting mechanism to be use by the service provider. The 'sort' identifies the sort criteria to be used for the records in the response message. Use with the orderBy parameter. The form of implementation is described in the corresponding binding document(s).</param>
        /// <param name="orderBy">This is used as part of the sorting mechanism to be use by the service provider. This defines the form of ordering for response to the sorted request i.e. ascending (asc) or descending (desc). The form of implementation is described in the corresponding binding document(s).</param>
        /// <param name="filter">This is used for the data filtering mechanism to be applied by the service provider. It defines the filtering rules to be applied when identifying the records to be supplied in the response message. The form of implementation is described in the corresponding binding document(s).</param>
        /// <param name="fields">This is used as part of the field selection mechanism to be applied by the service provider. This identifies the range of fields that should be supplied in the response message. The form of implementation is described in the corresponding binding document(s).</param>
        /// <returns>This is the response when the request has been completed successfully. It is the set of CFDocuments from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CFDocumentSet> GetAllCFDocumentsAsync(int? limit, int? offset, string sort, OrderBy? orderBy, string filter, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("CFDocuments?");
            if (limit != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("limit") + "=").Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (offset != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("offset") + "=").Append(System.Uri.EscapeDataString(ConvertToString(offset, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (sort != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("sort") + "=").Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderBy != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("orderBy") + "=").Append(System.Uri.EscapeDataString(ConvertToString(orderBy, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (filter != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("filter") + "=").Append(System.Uri.EscapeDataString(ConvertToString(filter, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CFDocumentSet>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("An invalid selection field was supplied and data filtering on the selection criteria was not possible i.e. \'invalid_selection_field\'. This is accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("The request was not correctly authorised i.e. \'unauthorisedrequest\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This is used to indicate that the server can be reached and process the request but refuses to take any further action i.e. \'forbidden\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("Either the supplied identifier is unknown in the Service Provider and so the object could not be changed or an invalid UUID has been supplied. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'. The statement \'Unknown Object\' of \'Invalid UUID\' should also be presented.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("The server is receiving too many requests i.e. \'server_busy\'. Retry at a later time. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This code should be used only if there is catastrophic error and there is not a more appropriate code i.e. \'internal_server_error\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This is the response data payload to be supplied when the HTTP code is NOT explicitly defined. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\' and the appropriate \'codeMinor\' value. The associated HTTP code will also be supplied.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>The REST read request message for the getCFDocument() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework Document that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFDocument from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CFDocument> GetCFDocumentAsync(string sourcedId)
        {
            return GetCFDocumentAsync(sourcedId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>The REST read request message for the getCFDocument() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework Document that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFDocument from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CFDocument> GetCFDocumentAsync(string sourcedId, System.Threading.CancellationToken cancellationToken)
        {
            if (sourcedId == null)
                throw new System.ArgumentNullException("sourcedId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("CFDocuments/{sourcedId}");
            urlBuilder_.Replace("{sourcedId}", System.Uri.EscapeDataString(ConvertToString(sourcedId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CFDocument>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("An invalid selection field was supplied and data filtering on the selection criteria was not possible i.e. \'invalid_selection_field\'. This is accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("The request was not correctly authorised i.e. \'unauthorisedrequest\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This is used to indicate that the server can be reached and process the request but refuses to take any further action i.e. \'forbidden\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("Either the supplied identifier is unknown in the Service Provider and so the object could not be changed or an invalid UUID has been supplied. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'. The statement \'Unknown Object\' of \'Invalid UUID\' should also be presented.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("The server is receiving too many requests i.e. \'server_busy\'. Retry at a later time. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This code should be used only if there is catastrophic error and there is not a more appropriate code i.e. \'internal_server_error\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This is the response data payload to be supplied when the HTTP code is NOT explicitly defined. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\' and the appropriate \'codeMinor\' value. The associated HTTP code will also be supplied.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>The REST read request message for the getCFItemAssociations() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the CFItem for which ALL associations are to be supplied.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFItem and set of CFAssociations from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CFAssociationSet> GetCFItemAssociationsAsync(string sourcedId)
        {
            return GetCFItemAssociationsAsync(sourcedId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>The REST read request message for the getCFItemAssociations() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the CFItem for which ALL associations are to be supplied.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFItem and set of CFAssociations from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CFAssociationSet> GetCFItemAssociationsAsync(string sourcedId, System.Threading.CancellationToken cancellationToken)
        {
            if (sourcedId == null)
                throw new System.ArgumentNullException("sourcedId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("CFItemAssociations/{sourcedId}");
            urlBuilder_.Replace("{sourcedId}", System.Uri.EscapeDataString(ConvertToString(sourcedId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CFAssociationSet>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("An invalid selection field was supplied and data filtering on the selection criteria was not possible i.e. \'invalid_selection_field\'. This is accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("The request was not correctly authorised i.e. \'unauthorisedrequest\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This is used to indicate that the server can be reached and process the request but refuses to take any further action i.e. \'forbidden\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("Either the supplied identifier is unknown in the Service Provider and so the object could not be changed or an invalid UUID has been supplied. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'. The statement \'Unknown Object\' of \'Invalid UUID\' should also be presented.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("The server is receiving too many requests i.e. \'server_busy\'. Retry at a later time. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This code should be used only if there is catastrophic error and there is not a more appropriate code i.e. \'internal_server_error\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This is the response data payload to be supplied when the HTTP code is NOT explicitly defined. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\' and the appropriate \'codeMinor\' value. The associated HTTP code will also be supplied.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>The REST read request message for the getCFItemType() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework ItemType that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFItemType and child CFItemTypes from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CFItemTypeSet> GetCFItemTypeAsync(string sourcedId)
        {
            return GetCFItemTypeAsync(sourcedId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>The REST read request message for the getCFItemType() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework ItemType that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFItemType and child CFItemTypes from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CFItemTypeSet> GetCFItemTypeAsync(string sourcedId, System.Threading.CancellationToken cancellationToken)
        {
            if (sourcedId == null)
                throw new System.ArgumentNullException("sourcedId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("CFItemTypes/{sourcedId}");
            urlBuilder_.Replace("{sourcedId}", System.Uri.EscapeDataString(ConvertToString(sourcedId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CFItemTypeSet>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("An invalid selection field was supplied and data filtering on the selection criteria was not possible i.e. \'invalid_selection_field\'. This is accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("The request was not correctly authorised i.e. \'unauthorisedrequest\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This is used to indicate that the server can be reached and process the request but refuses to take any further action i.e. \'forbidden\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("Either the supplied identifier is unknown in the Service Provider and so the object could not be changed or an invalid UUID has been supplied. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'. The statement \'Unknown Object\' of \'Invalid UUID\' should also be presented.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("The server is receiving too many requests i.e. \'server_busy\'. Retry at a later time. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This code should be used only if there is catastrophic error and there is not a more appropriate code i.e. \'internal_server_error\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This is the response data payload to be supplied when the HTTP code is NOT explicitly defined. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\' and the appropriate \'codeMinor\' value. The associated HTTP code will also be supplied.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>The REST read request message for the getCFItem() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework Item that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFItem from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CFItem> GetCFItemAsync(string sourcedId)
        {
            return GetCFItemAsync(sourcedId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>The REST read request message for the getCFItem() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework Item that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFItem from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CFItem> GetCFItemAsync(string sourcedId, System.Threading.CancellationToken cancellationToken)
        {
            if (sourcedId == null)
                throw new System.ArgumentNullException("sourcedId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("CFItems/{sourcedId}");
            urlBuilder_.Replace("{sourcedId}", System.Uri.EscapeDataString(ConvertToString(sourcedId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CFItem>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("An invalid selection field was supplied and data filtering on the selection criteria was not possible i.e. \'invalid_selection_field\'. This is accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("The request was not correctly authorised i.e. \'unauthorisedrequest\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This is used to indicate that the server can be reached and process the request but refuses to take any further action i.e. \'forbidden\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("Either the supplied identifier is unknown in the Service Provider and so the object could not be changed or an invalid UUID has been supplied. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'. The statement \'Unknown Object\' of \'Invalid UUID\' should also be presented.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("The server is receiving too many requests i.e. \'server_busy\'. Retry at a later time. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This code should be used only if there is catastrophic error and there is not a more appropriate code i.e. \'internal_server_error\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This is the response data payload to be supplied when the HTTP code is NOT explicitly defined. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\' and the appropriate \'codeMinor\' value. The associated HTTP code will also be supplied.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>The REST read request message for the getCFLicense() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework License that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFLicense from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CFLicense> GetCFLicenseAsync(string sourcedId)
        {
            return GetCFLicenseAsync(sourcedId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>The REST read request message for the getCFLicense() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework License that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFLicense from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CFLicense> GetCFLicenseAsync(string sourcedId, System.Threading.CancellationToken cancellationToken)
        {
            if (sourcedId == null)
                throw new System.ArgumentNullException("sourcedId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("CFLicenses/{sourcedId}");
            urlBuilder_.Replace("{sourcedId}", System.Uri.EscapeDataString(ConvertToString(sourcedId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CFLicense>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("An invalid selection field was supplied and data filtering on the selection criteria was not possible i.e. \'invalid_selection_field\'. This is accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("The request was not correctly authorised i.e. \'unauthorisedrequest\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This is used to indicate that the server can be reached and process the request but refuses to take any further action i.e. \'forbidden\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("Either the supplied identifier is unknown in the Service Provider and so the object could not be changed or an invalid UUID has been supplied. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'. The statement \'Unknown Object\' of \'Invalid UUID\' should also be presented.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("The server is receiving too many requests i.e. \'server_busy\'. Retry at a later time. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This code should be used only if there is catastrophic error and there is not a more appropriate code i.e. \'internal_server_error\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This is the response data payload to be supplied when the HTTP code is NOT explicitly defined. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\' and the appropriate \'codeMinor\' value. The associated HTTP code will also be supplied.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>The REST read request message for the getCFPackage() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework Document that is to be read from the service provider and supplied with all of its component artefacts.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFPackage from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CFPackage> GetCFPackageAsync(string sourcedId)
        {
            return GetCFPackageAsync(sourcedId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>The REST read request message for the getCFPackage() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework Document that is to be read from the service provider and supplied with all of its component artefacts.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFPackage from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CFPackage> GetCFPackageAsync(string sourcedId, System.Threading.CancellationToken cancellationToken)
        {
            if (sourcedId == null)
                throw new System.ArgumentNullException("sourcedId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("CFPackages/{sourcedId}");
            urlBuilder_.Replace("{sourcedId}", System.Uri.EscapeDataString(ConvertToString(sourcedId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CFPackage>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("An invalid selection field was supplied and data filtering on the selection criteria was not possible i.e. \'invalid_selection_field\'. This is accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("The request was not correctly authorised i.e. \'unauthorisedrequest\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This is used to indicate that the server can be reached and process the request but refuses to take any further action i.e. \'forbidden\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("Either the supplied identifier is unknown in the Service Provider and so the object could not be changed or an invalid UUID has been supplied. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'. The statement \'Unknown Object\' of \'Invalid UUID\' should also be presented.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("The server is receiving too many requests i.e. \'server_busy\'. Retry at a later time. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This code should be used only if there is catastrophic error and there is not a more appropriate code i.e. \'internal_server_error\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This is the response data payload to be supplied when the HTTP code is NOT explicitly defined. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\' and the appropriate \'codeMinor\' value. The associated HTTP code will also be supplied.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>The REST read request message for the getCFRubric() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework Rubric that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFRubric from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CFRubric> GetCFRubricAsync(string sourcedId)
        {
            return GetCFRubricAsync(sourcedId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>The REST read request message for the getCFRubric() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework Rubric that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFRubric from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CFRubric> GetCFRubricAsync(string sourcedId, System.Threading.CancellationToken cancellationToken)
        {
            if (sourcedId == null)
                throw new System.ArgumentNullException("sourcedId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("CFRubrics/{sourcedId}");
            urlBuilder_.Replace("{sourcedId}", System.Uri.EscapeDataString(ConvertToString(sourcedId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CFRubric>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("An invalid selection field was supplied and data filtering on the selection criteria was not possible i.e. \'invalid_selection_field\'. This is accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("The request was not correctly authorised i.e. \'unauthorisedrequest\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This is used to indicate that the server can be reached and process the request but refuses to take any further action i.e. \'forbidden\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("Either the supplied identifier is unknown in the Service Provider and so the object could not be changed or an invalid UUID has been supplied. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'. The statement \'Unknown Object\' of \'Invalid UUID\' should also be presented.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("The server is receiving too many requests i.e. \'server_busy\'. Retry at a later time. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This code should be used only if there is catastrophic error and there is not a more appropriate code i.e. \'internal_server_error\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This is the response data payload to be supplied when the HTTP code is NOT explicitly defined. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\' and the appropriate \'codeMinor\' value. The associated HTTP code will also be supplied.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>The REST read request message for the getCFSubject() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework Subject that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFSubject and child CFSubjects from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CFSubjectSet> GetCFSubjectAsync(string sourcedId)
        {
            return GetCFSubjectAsync(sourcedId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>The REST read request message for the getCFSubject() API call.</summary>
        /// <param name="sourcedId">The UUID that identifies the Competency Framework Subject that is to be read from the service provider.</param>
        /// <returns>This is the response when the request has been completed successfully. It is the CFSubject and child CFSubjects from the service provider.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CFSubjectSet> GetCFSubjectAsync(string sourcedId, System.Threading.CancellationToken cancellationToken)
        {
            if (sourcedId == null)
                throw new System.ArgumentNullException("sourcedId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("CFSubjects/{sourcedId}");
            urlBuilder_.Replace("{sourcedId}", System.Uri.EscapeDataString(ConvertToString(sourcedId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CFSubjectSet>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("An invalid selection field was supplied and data filtering on the selection criteria was not possible i.e. \'invalid_selection_field\'. This is accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("The request was not correctly authorised i.e. \'unauthorisedrequest\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This is used to indicate that the server can be reached and process the request but refuses to take any further action i.e. \'forbidden\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("Either the supplied identifier is unknown in the Service Provider and so the object could not be changed or an invalid UUID has been supplied. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'. The statement \'Unknown Object\' of \'Invalid UUID\' should also be presented.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("The server is receiving too many requests i.e. \'server_busy\'. Retry at a later time. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This code should be used only if there is catastrophic error and there is not a more appropriate code i.e. \'internal_server_error\'. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\'.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Imsx_StatusInfo>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Imsx_StatusInfo>("This is the response data payload to be supplied when the HTTP code is NOT explicitly defined. This would be accompanied by the \'codeMajor/severity\' values of \'failure/error\' and the appropriate \'codeMinor\' value. The associated HTTP code will also be supplied.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }
    
            public T Object { get; }
    
            public string Text { get; }
        }
    
        public bool ReadResponseAsString { get; set; }
        
        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }
        
            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }
    
        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
                }
            }
            else if (value is bool) {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array) value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }
        
            return System.Convert.ToString(value, cultureInfo);
        }
    }

    /// <summary>This is the container for the data about the relationship between two CFDocuments or between two CFItems outside of the context of a CFPackage or CFItem.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class CFAssociation : CFPckgAssociation
    {
        [Newtonsoft.Json.JsonProperty("CFDocumentURI", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LinkURI CFDocumentURI { get; set; }
    
    
    }
    
    /// <summary>This is the container for information about a set of associations that have been labelled as a group (the nature of the group being defined by this container).</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class CFAssociationGrouping 
    {
        [Newtonsoft.Json.JsonProperty("identifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9a-f]{8}-[0-9a-f]{4}-[1-5]{1}[0-9a-f]{3}-[8-9a-b]{1}[0-9a-f]{3}-[0-9a-f]{12}")]
        public System.Guid Identifier { get; set; }
    
        /// <summary>Model Primitive Datatype = AnyURI</summary>
        [Newtonsoft.Json.JsonProperty("uri", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Uri Uri { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("title", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Title { get; set; }
    
        /// <summary>Model Primitive Datatype = String</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Model Primitive Datatype = DateTime</summary>
        [Newtonsoft.Json.JsonProperty("lastChangeDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset LastChangeDateTime { get; set; }
    
    
    }
    
    /// <summary>This is the container for a collection of CFAssociations. There must be at least one CFAssociation. Note that the association can be between CFDocuments or between CFItems.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class CFAssociationSet 
    {
        [Newtonsoft.Json.JsonProperty("CFItem", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public CFItem CFItem { get; set; } = new CFItem();
    
        [Newtonsoft.Json.JsonProperty("CFAssociations", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<CFPckgAssociation> CFAssociations { get; set; } = new System.Collections.ObjectModel.Collection<CFPckgAssociation>();
    
    
    }
    
    /// <summary>The container for the definition of a concept which is addressed by the competency framework.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class CFConcept 
    {
        [Newtonsoft.Json.JsonProperty("identifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9a-f]{8}-[0-9a-f]{4}-[1-5]{1}[0-9a-f]{3}-[8-9a-b]{1}[0-9a-f]{3}-[0-9a-f]{12}")]
        public System.Guid Identifier { get; set; }
    
        /// <summary>Model Primitive Datatype = AnyURI</summary>
        [Newtonsoft.Json.JsonProperty("uri", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Uri Uri { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("title", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Title { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("keywords", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Keywords { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("hierarchyCode", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string HierarchyCode { get; set; }
    
        /// <summary>Model Primitive Datatype = String</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Model Primitive Datatype = DateTime</summary>
        [Newtonsoft.Json.JsonProperty("lastChangeDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset LastChangeDateTime { get; set; }
    
    
    }
    
    /// <summary>The container for the set of CFConcepts supplied in the response payload. The relationship between the CFConcepts is determined by the 'hierarchyCode'. The first CFConcept is that which has been specified in the call. The other CFConcepts are the set of children as determined by their place in the 'hierarchyCode' of the CFConcept.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class CFConceptSet 
    {
        [Newtonsoft.Json.JsonProperty("CFConcepts", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<CFConcept> CFConcepts { get; set; } = new System.Collections.ObjectModel.Collection<CFConcept>();
    
    
    }
    
    /// <summary>The container for the set of definitions used for the competency framework i.e. the set of CFSubjects, CFConcepts, CFItemTypes, CFAssociationGroupings and CFLicenses.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class CFDefinition 
    {
        [Newtonsoft.Json.JsonProperty("CFConcepts", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<CFConcept> CFConcepts { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CFSubjects", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<CFSubject> CFSubjects { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CFLicenses", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<CFLicense> CFLicenses { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CFItemTypes", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<CFItemType> CFItemTypes { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CFAssociationGroupings", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<CFAssociationGrouping> CFAssociationGroupings { get; set; }
    
    
    }
    
    /// <summary>The container for the data about a competency framework document (CFDocument) when exchanged outside of the context of a CFPackage. A CFDocument is the root for the creation of a learning standard/competency.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class CFDocument : CFPckgDocument
    {
        [Newtonsoft.Json.JsonProperty("CFPackageURI", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public LinkURI CFPackageURI { get; set; } = new LinkURI();
    
    
    }
    
    /// <summary>This is the container for a collection of CFDocuments. There must be at least one CFDocument.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class CFDocumentSet 
    {
        [Newtonsoft.Json.JsonProperty("CFDocuments", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<CFDocument> CFDocuments { get; set; } = new System.Collections.ObjectModel.Collection<CFDocument>();
    
    
    }
    
    /// <summary>This is the container for the CFItem data outside of the context of a CFPackage. This is the content that either describes a specific competency (learning objective) or describes a grouping of competencies within the taxonomy of a Competency Framework Document. </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class CFItem : CFPckgItem
    {
        [Newtonsoft.Json.JsonProperty("CFDocumentURI", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public LinkURI CFDocumentURI { get; set; } = new LinkURI();
    
    
    }
    
    /// <summary>The container for the ItemType information use within the competency framework.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class CFItemType 
    {
        [Newtonsoft.Json.JsonProperty("identifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9a-f]{8}-[0-9a-f]{4}-[1-5]{1}[0-9a-f]{3}-[8-9a-b]{1}[0-9a-f]{3}-[0-9a-f]{12}")]
        public System.Guid Identifier { get; set; }
    
        /// <summary>Model Primitive Datatype = AnyURI</summary>
        [Newtonsoft.Json.JsonProperty("uri", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Uri Uri { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("title", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Title { get; set; }
    
        /// <summary>Model Primitive Datatype = String</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Description { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("hierarchyCode", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string HierarchyCode { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("typeCode", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TypeCode { get; set; }
    
        /// <summary>Model Primitive Datatype = DateTime</summary>
        [Newtonsoft.Json.JsonProperty("lastChangeDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset LastChangeDateTime { get; set; }
    
    
    }
    
    /// <summary>The container for the set of CFItemTypes supplied in the response payload. The relationship between the CFItemTypes is determined by the 'hierarchyCode'. The first CFItemType is that which has been specified in the call. The other CFItemTypes are the set of children as determined by their place in the 'hierarchyCode' of the CFItemType.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class CFItemTypeSet 
    {
        [Newtonsoft.Json.JsonProperty("CFItemTypes", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<CFItemType> CFItemTypes { get; set; } = new System.Collections.ObjectModel.Collection<CFItemType>();
    
    
    }
    
    /// <summary>The container for the information about a license used within the competency framework.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class CFLicense 
    {
        [Newtonsoft.Json.JsonProperty("identifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9a-f]{8}-[0-9a-f]{4}-[1-5]{1}[0-9a-f]{3}-[8-9a-b]{1}[0-9a-f]{3}-[0-9a-f]{12}")]
        public System.Guid Identifier { get; set; }
    
        /// <summary>Model Primitive Datatype = AnyURI</summary>
        [Newtonsoft.Json.JsonProperty("uri", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Uri Uri { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("title", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Title { get; set; }
    
        /// <summary>Model Primitive Datatype = String</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Model Primitive Datatype = String</summary>
        [Newtonsoft.Json.JsonProperty("licenseText", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string LicenseText { get; set; }
    
        /// <summary>Model Primitive Datatype = DateTime</summary>
        [Newtonsoft.Json.JsonProperty("lastChangeDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset LastChangeDateTime { get; set; }
    
    
    }
    
    /// <summary>This is the container for all of the data for a Competency Framework Package i.e. the root CFDocument and ALL of the corresponding components i.e. the CFItems, CFAssociations and CFDefinitions.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class CFPackage 
    {
        [Newtonsoft.Json.JsonProperty("CFDocument", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public CFPckgDocument CFDocument { get; set; } = new CFPckgDocument();
    
        [Newtonsoft.Json.JsonProperty("CFItems", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<CFPckgItem> CFItems { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CFAssociations", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<CFPckgAssociation> CFAssociations { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CFDefinitions", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CFDefinition CFDefinitions { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CFRubrics", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<CFRubric> CFRubrics { get; set; }
    
    
    }
    
    /// <summary>This is the container for the data about the relationship between two CFDocuments or between two CFItems within the context of a CFPackage.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class CFPckgAssociation 
    {
        [Newtonsoft.Json.JsonProperty("identifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9a-f]{8}-[0-9a-f]{4}-[1-5]{1}[0-9a-f]{3}-[8-9a-b]{1}[0-9a-f]{3}-[0-9a-f]{12}")]
        public System.Guid Identifier { get; set; }
    
        [Newtonsoft.Json.JsonProperty("associationType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CFPckgAssociationAssociationType AssociationType { get; set; }
    
        /// <summary>Model Primitive Datatype = Integer</summary>
        [Newtonsoft.Json.JsonProperty("sequenceNumber", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int SequenceNumber { get; set; }
    
        /// <summary>Model Primitive Datatype = AnyURI</summary>
        [Newtonsoft.Json.JsonProperty("uri", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Uri Uri { get; set; }
    
        [Newtonsoft.Json.JsonProperty("originNodeURI", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public LinkGenURI OriginNodeURI { get; set; } = new LinkGenURI();
    
        [Newtonsoft.Json.JsonProperty("destinationNodeURI", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public LinkGenURI DestinationNodeURI { get; set; } = new LinkGenURI();
    
        [Newtonsoft.Json.JsonProperty("CFAssociationGroupingURI", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LinkURI CFAssociationGroupingURI { get; set; }
    
        /// <summary>Model Primitive Datatype = DateTime</summary>
        [Newtonsoft.Json.JsonProperty("lastChangeDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset LastChangeDateTime { get; set; }
    
    
    }
    
    /// <summary>The container for the data about a competency framework document (CFDocument) within a CFPackage. A CFDocument is the root for the creation of a learning standard/competency.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class CFPckgDocument 
    {
        [Newtonsoft.Json.JsonProperty("identifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9a-f]{8}-[0-9a-f]{4}-[1-5]{1}[0-9a-f]{3}-[8-9a-b]{1}[0-9a-f]{3}-[0-9a-f]{12}")]
        public System.Guid Identifier { get; set; }
    
        /// <summary>Model Primitive Datatype = AnyURI</summary>
        [Newtonsoft.Json.JsonProperty("uri", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Uri Uri { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("creator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Creator { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("title", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Title { get; set; }
    
        /// <summary>Model Primitive Datatype = DateTime</summary>
        [Newtonsoft.Json.JsonProperty("lastChangeDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset LastChangeDateTime { get; set; }
    
        [Newtonsoft.Json.JsonProperty("officialSourceURL", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Uri OfficialSourceURL { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("publisher", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Publisher { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("subject", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Subject { get; set; }
    
        [Newtonsoft.Json.JsonProperty("subjectURI", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LinkURI> SubjectURI { get; set; }
    
        /// <summary>Model Primitive Datatype = Language</summary>
        [Newtonsoft.Json.JsonProperty("language", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Language { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Version { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("adoptionStatus", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AdoptionStatus { get; set; }
    
        /// <summary>Model Primitive Datatype = Date</summary>
        [Newtonsoft.Json.JsonProperty("statusStartDate", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(DateFormatConverter))]
        public System.DateTimeOffset StatusStartDate { get; set; }
    
        /// <summary>Model Primitive Datatype = Date</summary>
        [Newtonsoft.Json.JsonProperty("statusEndDate", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(DateFormatConverter))]
        public System.DateTimeOffset StatusEndDate { get; set; }
    
        [Newtonsoft.Json.JsonProperty("licenseURI", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LinkURI LicenseURI { get; set; }
    
        /// <summary>Model Primitive Datatype = String</summary>
        [Newtonsoft.Json.JsonProperty("notes", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Notes { get; set; }
    
    
    }
    
    /// <summary>This is the container for the CFItem data within the context of a CFPackage. This is the content that either describes a specific competency (learning objective) or describes a grouping of competencies within the taxonomy of a Competency Framework Document. </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class CFPckgItem 
    {
        [Newtonsoft.Json.JsonProperty("identifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9a-f]{8}-[0-9a-f]{4}-[1-5]{1}[0-9a-f]{3}-[8-9a-b]{1}[0-9a-f]{3}-[0-9a-f]{12}")]
        public System.Guid Identifier { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("fullStatement", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string FullStatement { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("alternativeLabel", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AlternativeLabel { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("CFItemType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CFItemType { get; set; }
    
        /// <summary>Model Primitive Datatype = AnyURI</summary>
        [Newtonsoft.Json.JsonProperty("uri", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Uri Uri { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("humanCodingScheme", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string HumanCodingScheme { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("listEnumeration", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ListEnumeration { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("abbreviatedStatement", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AbbreviatedStatement { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("conceptKeywords", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> ConceptKeywords { get; set; }
    
        [Newtonsoft.Json.JsonProperty("conceptKeywordsURI", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LinkURI ConceptKeywordsURI { get; set; }
    
        /// <summary>Model Primitive Datatype = String</summary>
        [Newtonsoft.Json.JsonProperty("notes", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Notes { get; set; }
    
        /// <summary>Model Primitive Datatype = Language</summary>
        [Newtonsoft.Json.JsonProperty("language", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Language { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("educationLevel", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> EducationLevel { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CFItemTypeURI", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LinkURI CFItemTypeURI { get; set; }
    
        [Newtonsoft.Json.JsonProperty("licenseURI", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LinkURI LicenseURI { get; set; }
    
        /// <summary>Model Primitive Datatype = Date</summary>
        [Newtonsoft.Json.JsonProperty("statusStartDate", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(DateFormatConverter))]
        public System.DateTimeOffset StatusStartDate { get; set; }
    
        /// <summary>Model Primitive Datatype = Date</summary>
        [Newtonsoft.Json.JsonProperty("statusEndDate", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(DateFormatConverter))]
        public System.DateTimeOffset StatusEndDate { get; set; }
    
        /// <summary>Model Primitive Datatype = DateTime</summary>
        [Newtonsoft.Json.JsonProperty("lastChangeDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset LastChangeDateTime { get; set; }
    
    
    }
    
    /// <summary>The container for the definition of a rubric which is addressed by the competency framework. This includes the set of associated CFRubricCriteria and CFRubricCriterionLevels.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class CFRubric 
    {
        [Newtonsoft.Json.JsonProperty("identifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9a-f]{8}-[0-9a-f]{4}-[1-5]{1}[0-9a-f]{3}-[8-9a-b]{1}[0-9a-f]{3}-[0-9a-f]{12}")]
        public System.Guid Identifier { get; set; }
    
        /// <summary>Model Primitive Datatype = AnyURI</summary>
        [Newtonsoft.Json.JsonProperty("uri", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Uri Uri { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("title", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Title { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Model Primitive Datatype = DateTime</summary>
        [Newtonsoft.Json.JsonProperty("lastChangeDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset LastChangeDateTime { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CFRubricCriteria", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<CFRubricCriterion> CFRubricCriteria { get; set; }
    
    
    }
    
    /// <summary>The container for the definition of a rubric criterion which is addressed by the competency framework.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class CFRubricCriterion 
    {
        [Newtonsoft.Json.JsonProperty("identifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9a-f]{8}-[0-9a-f]{4}-[1-5]{1}[0-9a-f]{3}-[8-9a-b]{1}[0-9a-f]{3}-[0-9a-f]{12}")]
        public System.Guid Identifier { get; set; }
    
        /// <summary>Model Primitive Datatype = AnyURI</summary>
        [Newtonsoft.Json.JsonProperty("uri", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Uri Uri { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Category { get; set; }
    
        /// <summary>Model Primitive Datatype = String</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CFItemURI", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LinkURI CFItemURI { get; set; }
    
        /// <summary>Model Primitive Datatype = Float</summary>
        [Newtonsoft.Json.JsonProperty("weight", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double Weight { get; set; }
    
        /// <summary>Model Primitive Datatype = Integer</summary>
        [Newtonsoft.Json.JsonProperty("position", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Position { get; set; }
    
        [Newtonsoft.Json.JsonProperty("rubricId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9a-f]{8}-[0-9a-f]{4}-[1-5]{1}[0-9a-f]{3}-[8-9a-b]{1}[0-9a-f]{3}-[0-9a-f]{12}")]
        public System.Guid RubricId { get; set; }
    
        /// <summary>Model Primitive Datatype = DateTime</summary>
        [Newtonsoft.Json.JsonProperty("lastChangeDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset LastChangeDateTime { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CFRubricCriterionLevels", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<CFRubricCriterionLevel> CFRubricCriterionLevels { get; set; }
    
    
    }
    
    /// <summary>The container for the definition of a criterion level which is addressed by the competency framework.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class CFRubricCriterionLevel 
    {
        [Newtonsoft.Json.JsonProperty("identifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9a-f]{8}-[0-9a-f]{4}-[1-5]{1}[0-9a-f]{3}-[8-9a-b]{1}[0-9a-f]{3}-[0-9a-f]{12}")]
        public System.Guid Identifier { get; set; }
    
        /// <summary>Model Primitive Datatype = AnyURI</summary>
        [Newtonsoft.Json.JsonProperty("uri", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Uri Uri { get; set; }
    
        /// <summary>Model Primitive Datatype = String</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("quality", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Quality { get; set; }
    
        /// <summary>Model Primitive Datatype = Float</summary>
        [Newtonsoft.Json.JsonProperty("score", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double Score { get; set; }
    
        /// <summary>Model Primitive Datatype = String</summary>
        [Newtonsoft.Json.JsonProperty("feedback", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Feedback { get; set; }
    
        /// <summary>Model Primitive Datatype = Integer</summary>
        [Newtonsoft.Json.JsonProperty("position", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Position { get; set; }
    
        [Newtonsoft.Json.JsonProperty("rubricCriterionId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9a-f]{8}-[0-9a-f]{4}-[1-5]{1}[0-9a-f]{3}-[8-9a-b]{1}[0-9a-f]{3}-[0-9a-f]{12}")]
        public System.Guid RubricCriterionId { get; set; }
    
        /// <summary>Model Primitive Datatype = DateTime</summary>
        [Newtonsoft.Json.JsonProperty("lastChangeDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset LastChangeDateTime { get; set; }
    
    
    }
    
    /// <summary>The container for the definition of a topic or academic subject which is addressed by the competency framework.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class CFSubject 
    {
        [Newtonsoft.Json.JsonProperty("identifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9a-f]{8}-[0-9a-f]{4}-[1-5]{1}[0-9a-f]{3}-[8-9a-b]{1}[0-9a-f]{3}-[0-9a-f]{12}")]
        public System.Guid Identifier { get; set; }
    
        /// <summary>Model Primitive Datatype = AnyURI</summary>
        [Newtonsoft.Json.JsonProperty("uri", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Uri Uri { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("title", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Title { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("hierarchyCode", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string HierarchyCode { get; set; }
    
        /// <summary>Model Primitive Datatype = String</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Model Primitive Datatype = DateTime</summary>
        [Newtonsoft.Json.JsonProperty("lastChangeDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset LastChangeDateTime { get; set; }
    
    
    }
    
    /// <summary>The container for the set of CFSubjects supplied in the response payload. The relationship between the CFSubjects is determined by the 'hierarchyCode'. The first CFSubject is that which has been specified in the call. The other CFSubjects are the set of children as determined by their place in the 'hierarchyCode' of the CFSubject.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class CFSubjectSet 
    {
        [Newtonsoft.Json.JsonProperty("CFSubjects", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<CFSubject> CFSubjects { get; set; } = new System.Collections.ObjectModel.Collection<CFSubject>();
    
    
    }
    
    /// <summary>A container for the information that is used to achieve the link data reference.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class LinkGenURI 
    {
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("title", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Title { get; set; }
    
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("identifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Identifier { get; set; }
    
        /// <summary>Model Primitive Datatype = AnyURI</summary>
        [Newtonsoft.Json.JsonProperty("uri", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Uri Uri { get; set; }
    
    
    }
    
    /// <summary>A container for the information that is used to achieve the link data reference.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class LinkURI 
    {
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("title", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Title { get; set; }
    
        [Newtonsoft.Json.JsonProperty("identifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9a-f]{8}-[0-9a-f]{4}-[1-5]{1}[0-9a-f]{3}-[8-9a-b]{1}[0-9a-f]{3}-[0-9a-f]{12}")]
        public System.Guid Identifier { get; set; }
    
        /// <summary>Model Primitive Datatype = AnyURI</summary>
        [Newtonsoft.Json.JsonProperty("uri", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Uri Uri { get; set; }
    
    
    }
    
    /// <summary>This is the container for the set of code minor status codes reported in the responses from the Service Provider.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class Imsx_CodeMinor 
    {
        [Newtonsoft.Json.JsonProperty("imsx_codeMinorField", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<Imsx_CodeMinorField> Imsx_codeMinorField { get; set; } = new System.Collections.ObjectModel.Collection<Imsx_CodeMinorField>();
    
    
    }
    
    /// <summary>This is the container for a single code minor status code.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class Imsx_CodeMinorField 
    {
        /// <summary>Model Primitive Datatype = NormalizedString</summary>
        [Newtonsoft.Json.JsonProperty("imsx_codeMinorFieldName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Imsx_codeMinorFieldName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("imsx_codeMinorFieldValue", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Imsx_codeMinorFieldValue Imsx_codeMinorFieldValue { get; set; }
    
    
    }
    
    /// <summary>This is the container for the status code and associated information returned within the HTTP messages received from the Service Provider. For the CASE service this object will only be returned to provide information about a failed request i.e. it will NOT be in the payload for a successful request. See Appendix B for further information on the interpretation of the information contained within this class</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public partial class Imsx_StatusInfo 
    {
        [Newtonsoft.Json.JsonProperty("imsx_codeMajor", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Imsx_StatusInfoImsx_codeMajor Imsx_codeMajor { get; set; }
    
        [Newtonsoft.Json.JsonProperty("imsx_severity", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Imsx_StatusInfoImsx_severity Imsx_severity { get; set; }
    
        /// <summary>Model Primitive Datatype = String</summary>
        [Newtonsoft.Json.JsonProperty("imsx_description", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Imsx_description { get; set; }
    
        [Newtonsoft.Json.JsonProperty("imsx_codeMinor", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Imsx_CodeMinor Imsx_codeMinor { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public enum OrderBy
    {
        [System.Runtime.Serialization.EnumMember(Value = @"asc")]
        Asc = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"desc")]
        Desc = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public enum CFPckgAssociationAssociationType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"isChildOf")]
        IsChildOf = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"isPeerOf")]
        IsPeerOf = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"isPartOf")]
        IsPartOf = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"exactMatchOf")]
        ExactMatchOf = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"precedes")]
        Precedes = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"isRelatedTo")]
        IsRelatedTo = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"replacedBy")]
        ReplacedBy = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"exemplar")]
        Exemplar = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"hasSkillLevel")]
        HasSkillLevel = 8,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public enum Imsx_codeMinorFieldValue
    {
        [System.Runtime.Serialization.EnumMember(Value = @"fullsuccess")]
        Fullsuccess = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"invalid_sort_field")]
        Invalid_sort_field = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"invalid_selection_field")]
        Invalid_selection_field = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"forbidden")]
        Forbidden = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"unauthorisedrequest")]
        Unauthorisedrequest = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"internal_server_error")]
        Internal_server_error = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"unknownobject")]
        Unknownobject = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"server_busy")]
        Server_busy = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"invaliduuid")]
        Invaliduuid = 8,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public enum Imsx_StatusInfoImsx_codeMajor
    {
        [System.Runtime.Serialization.EnumMember(Value = @"success")]
        Success = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"processing")]
        Processing = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"failure")]
        Failure = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"unsupported")]
        Unsupported = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    public enum Imsx_StatusInfoImsx_severity
    {
        [System.Runtime.Serialization.EnumMember(Value = @"status")]
        Status = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"warning")]
        Warning = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"error")]
        Error = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.2)")]
    internal class DateFormatConverter : Newtonsoft.Json.Converters.IsoDateTimeConverter
    {
        public DateFormatConverter()
        {
            DateTimeFormat = "yyyy-MM-dd";
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.2))")]
    public partial class ApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException) 
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + response.Substring(0, response.Length >= 512 ? 512 : response.Length), innerException)
        {
            StatusCode = statusCode;
            Response = response; 
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.2))")]
    public partial class ApiException<TResult> : ApiException
    {
        public TResult Result { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException) 
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore 1591
#pragma warning restore 1573
#pragma warning restore  472
#pragma warning restore  114
#pragma warning restore  108